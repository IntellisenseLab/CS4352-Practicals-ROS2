# Lab 07

In the advanced simulation, we are going to extend our basic robot simulation with an obstacle avoider node.

## Updating my_robot.urdf

In my_robot.urdf replace the whole contents with:

```python

<?xml version="1.0" ?>
<robot name="My robot">
    <webots>
        <device reference="ds0" type="DistanceSensor">
            <ros>
                <topicName>/left_sensor</topicName>
                <alwaysOn>true</alwaysOn>
            </ros>
        </device>
        <device reference="ds1" type="DistanceSensor">
            <ros>
                <topicName>/right_sensor</topicName>
                <alwaysOn>true</alwaysOn>
            </ros>
        </device>
        <plugin type="sim_robot.my_robot_driver.MyRobotDriver" />
    </webots>
</robot>

```

## Creating a ROS node to avoid obstacles

The robot will use a standard ROS node to detect the wall and send motor commands to avoid it. 
In the sim_robot/sim_robot/ folder, create a file named obstacle_avoider.py with this code:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Range
from geometry_msgs.msg import Twist


MAX_RANGE = 0.15


class ObstacleAvoider(Node):
    def __init__(self):
        super().__init__('obstacle_avoider')

        self.__publisher = self.create_publisher(Twist, 'cmd_vel', 1)

        self.create_subscription(Range, 'left_sensor', self.__left_sensor_callback, 1)
        self.create_subscription(Range, 'right_sensor', self.__right_sensor_callback, 1)

    def __left_sensor_callback(self, message):
        self.__left_sensor_value = message.range

    def __right_sensor_callback(self, message):
        self.__right_sensor_value = message.range

        command_message = Twist()

        command_message.linear.x = 0.1

        if self.__left_sensor_value < 0.9 * MAX_RANGE or self.__right_sensor_value < 0.9 * MAX_RANGE:
            command_message.angular.z = -2.0

        self.__publisher.publish(command_message)


def main(args=None):
    rclpy.init(args=args)
    avoider = ObstacleAvoider()
    rclpy.spin(avoider)
    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    avoider.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Updating additional files

You have to modify these two other files to launch your new node.

Edit setup.py and replace 'console_scripts' with:

```python

'console_scripts': [
    'my_robot_driver = sim_robot.my_robot_driver:main',
    'obstacle_avoider = sim_robot.obstacle_avoider:main'
],

```

Go to the file robot_launch.py and replace it with:

```python

import os
import launch
from launch_ros.actions import Node
from launch import LaunchDescription
from ament_index_python.packages import get_package_share_directory
from webots_ros2_driver.webots_launcher import WebotsLauncher
from webots_ros2_driver.webots_controller import WebotsController


def generate_launch_description():
    package_dir = get_package_share_directory('sim_robot')
    robot_description_path = os.path.join(package_dir, 'resource', 'my_robot.urdf')

    webots = WebotsLauncher(
        world=os.path.join(package_dir, 'worlds', 'my_world.wbt')
    )

    my_robot_driver = WebotsController(
        robot_name='my_robot',
        parameters=[
            {'robot_description': robot_description_path},
        ]
    )

    obstacle_avoider = Node(
        package='sim_robot',
        executable='obstacle_avoider',
    )

    return LaunchDescription([
        webots,
        my_robot_driver,
        obstacle_avoider,
        launch.actions.RegisterEventHandler(
            event_handler=launch.event_handlers.OnProcessExit(
                target_action=webots,
                on_exit=[launch.actions.EmitEvent(event=launch.events.Shutdown())],
            )
        )
    ])

```

## Test the obstacle avoidance code

From a terminal in your ROS 2 workspace run :

```Linux
colcon build
source install/local_setup.bash
ros2 launch sim_robot robot_launch.py
```

Your robot should go forward and before hitting the wall it should turn clockwise.

Record the screen and upload a video that shows what happens when you test the code. 
Note : Name your video as "Simulation_advanced_<index_no>.mp4"
